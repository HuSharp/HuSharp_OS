
BIOS->MBR->loader

在开机的一瞬间，CS：IP强制初始化为 0xF000:0xFFF0,即为BIOS入口地址
BIOS:	0xF0000-0xFFFFF 64KB都为系统BIOS范围，被写入ROM中
	1.FFFF0-FFFFF BIOS的入口地址， jmp f000:e05b 16B只有这么一条语句，剩下的作为保留
	2.在 jmp 跳转后，检测内存，显卡外设信息，在内存0x000 - 0x3FF 建立IDT,并填写中断例程
	3.检测0盘0道1扇区的内容（MBR所在处）
MBR：	位于0盘0道1扇区（由于是 CHS扇区表示方法，即为最开始扇区），末尾为 0x55aa,被识别末尾魔数后，被加载到 0x7c00
	1.大小为 512 字节
	2.	
7c00：历史原因——尽可能留足够的空间给操作系统在32K内加载自己
0x7FFF - 512 - 512 + 1 // 开机扇区512字节，再留出512字节 

页目录表： （物理地址）0x100000~0x100fff 4KB
第一个页表：（物理地址）0x101000~0x101fff 4KB
为映射到 0xc0000000，对应的页目录项为第 768 个，由于一个页表(页表项4字节)表示 4MB = (4GB/4KB)*4字节
所以第 768 个页目录项对应的虚拟地址 4MB：0xc0000000~0xc003ffff 指向低端 4MB之内的物理地址
为了实现所有用户共享内核，因此将 各个用户的虚拟地址高 1 GB都指向内核所在的物理内存空间。即每个用户 768~1022（共254个PDE）都与其他进程一致。（即：提前将内核的所有PDE都定下来，在创建用户进程时，直接将内核对应PDE复制，以达到内核共享）。


虚拟地址 0xc0000000~0xc00fffff 映射 物理地址 0x00000000~0x000fffff(低端 1Mb 内存)
0xc0100000：堆的起始地址
0xc009f000是内核主线程栈顶，
0xc009e000是内核主线程的pcb. PCB占用 1 页 0x1000
0xc009a000:位图位置

 
0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存

0x9f000：内核主线程栈顶
内核估计 70 kb 左右。装载到 0x9f000绰绰有余
因此在 低端 1MB 下所用到的最高地址，即为 main线程的栈顶地址 0x9f000

0xc009a000:位图位置
一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000

由于 虚拟机配置 32 MB 物理内存，因此需要 1024 字节 bitmap -> 4kb * 1024 * 8 = 32 MB
即  1/4 页 ，但是我很任性，想搞 4 页，即 0x4000
又因为 pcb 位于 0xc009e000，所以将位图放在下面 0xc009e000 - 0x4000 = 0xc009a000

堆的起始地址：（为了让虚拟地址连续）
#define K_HEAP_START 0xc0100000 

